Traceback (most recent call last):
  File "/usr/local/lib/python3.10/dist-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/local/lib/python3.10/dist-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/usr/local/lib/python3.10/dist-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "/usr/lib/python3.10/asyncio/base_events.py", line 646, in run_until_complete
    return future.result()
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/usr/local/lib/python3.10/dist-packages/nbclient/client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# # The Helmholtz Equation with FEniCSx
# Authors: Stefano Tronci and JÃ¸rgen S. Dokken
#
# :::{note}
# You can run this code directly in your browser by clicking on the rocket logo
# (<i class="fas fa-rocket"></i>) at the top of the page, and clicking 'Binder'.
# This will open a Jupyter Notebook in a [Binder](https://mybinder.org/) environment which
# is set up to contain everything you need to run the code. **Don't forget to save a local
copy if you make any changes!**
#
# If you prefer, you can download the Jupyter Notebook file to run locally, by clicking the
# download logo ( <i class="fas fa-download"></i> ) at the top of the page and selecting
# '.ipynb'.
#
# If you are new to using Jupyter Notebooks, [this
# guide](https://www.dataquest.io/blog/jupyter-notebook-tutorial/) will help you get started.
# :::
#
# ## Prerequisites
#
# In order to be able to run the code presented in this tutorial you will need:
#
# * A working Python environment for your platform. For more information, refer to
#   [the Python website](https://www.python.org/);
# * A working FEniCS installation within your Python environment. For more information
#   refer to [the FEniCSx documentation](https://docs.fenicsproject.org/dolfinx/main/python/installation);
# * The following Python packages installed in your environment:
#     * `numpy`;
#     * `pyvista`;
#     * `ipygany`;
#
# A basic knowledge of Partial Differential Equations (PDEs) and FEM will be beneficial.
#
#
# ## Introduction
#
# This tutorial cover the basics on how to solve the Helmholtz equation with Neumann boundary conditions by using FEniCS.
#
# ### The Governing PDE
#
# #### The Helmholtz Equation
#
# The lossless wave equation reads:
#
# $$
# \nabla^2 p = \frac{1}{c^2}\frac{\partial^2 p}{\partial t^2}
# $$
#
# Where $p = p \left(\mathbf{x},t\right)$ is the unknown pressure disturbance field, in
# Pascal. $p$ is defined in $\overline{\Omega} \times T$ and has complex values. $c$ is
# the phase speed of sound in the medium, in metres per second.
#
# We impose that the pressure field is a steady state harmonic field:
#
# $$
# p = \tilde{p} \exp\left(j\omega t\right)
# $$
#
# Where $u$ is the unknown spatial part of the field. $u$ is defined in $\overline{\Omega}$
# and has complex values. $j$ is the imaginary unit and $\omega$ is the angular frequncy of
# the field, in radians per second. If $\nu$ denotes the frequency in Hertz we have:
#
# $$ \omega = 2\pi\nu = kc$$
#
# With $k$ the wave number.
#
# By substituting into the wave equation we obtain the Helmholtz equation:
#
# $$
# \nabla^2 \tilde{p} + k^2 \tilde{p}  = 0
# $$
#
# This is our governing PDE.
#
# #### Boundary Conditions
# The Helmholtz equation can be completed with Dirchlet, Neumann and Robin boundary conditions:
#
# * Dirchlet conditions impose a specific value of $\tilde{p}$ on $\partial \Omega$.
#   $$
#   \tilde{p}=p_{D} \quad\quad \text{on} \quad \partial\Omega_{D}
#   $$
# * Neumann conditions specify a normal particle velocity $v_{n}$ on $\partial \Omega$.
#   $$
#   v_{n}=-\frac{1}{j\rho_{0}\omega}\frac{\partial p}{\partial n}= \bar{v}_{n} \quad\quad \text{on} \quad \partial\Omega_{N}
#   $$
#   where $n$ is the outward normal vector of the boundary surface.
# * Robin conditions specify an acoustic impedance $Z$ on $\partial \Omega_{R}$ as well as an
#   optional particle velocity.
#   $$
#   p=Zv_{n}=-\frac{Z}{j\omega\rho_{0}}\frac{\partial p}{\partial n}= -\frac{1}{j\omega\rho_{0}A}\frac{\partial p}{\partial n}
#   \quad\quad \text{on} \quad \partial\Omega_{R}
#   $$
#
# ### The Weak Form
#
# We need to convert our PDE into a weak form to solve our problem with FEniCS. This is done
# by recognising that $u$ is a vector of an appropriate Sobolev space. Then, another test
# function $\phi$ is taken from the Sobolev space, with the requirement of being $0$ on
# $\partial \Omega$. Multiplication of the governing PDE with $\phi$ and integration by parts
# lead to the weak form. The weak form reads:
#
# $$
# \int_\Omega \nabla \tilde{p}  \cdot \nabla \phi^\star d\mathbf{x}
# - k^2 \int_\Omega \tilde{p}  \phi^\star d\mathbf{x}
# = \sum_{l=0}^{L-1}\int_{\partial \Omega_l} g_l \phi^\star ds
# $$
#
# Where we simplified notation by dropping the functions arguments. $d\mathbf{x}$ denotes the
# volume element of $\Omega$ while $ds$ denotes the surface element in $\partial \Omega$. $\star$
# denotes complex conjugation. Note that the equation above has the following form:
#
# $$
# a \left(u,\phi\right) = L\left(\phi\right)
# $$
#
# Where $a$ and $L$ are the bilinear and linear form respectively. FEniCS requires the specification of these two quantities.
#
# :::{note}
# The Neumann boundary conditions feature directly in the weak form. The same goes for Robin
# conditions. However, Dirchlet boundary conditions don't and are treated separately.
# :::
#
# ### More Details
#
# A similar tutorial for legacy FEniCS is presented at the links.
#
# * [Intro to FEniCS - Part 1](https://computational-acoustics.gitlab.io/website/posts/30-intro-to-fenics-part-1/).
# * [Intro to FEniCS - Part 2 ](https://computational-acoustics.gitlab.io/website/posts/31-intro-to-fenics-part-2/).
# * [Intro to FEniCS - Part 3 ](https://computational-acoustics.gitlab.io/website/posts/32-intro-to-fenics-part-3/).
#
# This tutorial focuses more on the code, whilst the ones above focus more on the derivation of the weak form.
#
# For more details about acoustics, FEniCS and computational methods the following books are recommended:
#
# * [Computational Acoustics of Noise Propagation in Fluids](https://link.springer.com/book/10.1007%2F978-3-540-77448-8).
# * [Solving PDEs in Python](https://link.springer.com/book/10.1007/978-3-319-52462-7).
# * [Fundamentals of Acoustics](https://www.wiley.com/en-gb/Fundamentals+of+Acoustics,+4th+Edition-p-9780471847892).
# * [The FEniCSx tutorial](https://jorgensd.github.io/dolfinx-tutorial/)
#
# ## Setup
#
# We now setup our simulation.
#
# First, we decide the shape of $\Omega$, then the properties of the medium and then the boundary conditions.
#
# ### Domain
#
# We choose a rectangular room with the following geometry:
#
# | Dimension | Symbol    | Value      |
# |-----------|-----------|------------|
# | Length    | $d_{x_0}$ | $4$ meters |
# | Width     | $d_{x_1}$ | $5$ meters |
# | Height    | $d_{x_2}$ | $3$ meters |
#
# Hence $\Omega = \left(0, d_{x_0} \right) \times \left(0, d_{x_1} \right) \times \left(0, d_{x_2} \right)$.
#
#
# ### Medium Properties
#
# We choose air at room temperature:
#
# | Property       | Symbol | Value                             |
# |----------------|--------|-----------------------------------|
# | Speed of Sound | $c$    | $343$ meters per second           |
# | Density        | $\rho$ | $1.205$ kilograms per cubic meter |
#
#
# ### Boundaries
#
# We partition $\partial \Omega$ in the $6$ walls of the room. We make $5$ of the rigid
# (normal particle velocity set to $0$) while we make one having uniform velocity.
#
# | Boundary Definition                                                                 | Particle Velocity Definition         |
# |-------------------------------------------------------------------------------------|--------------------------------------|
# | $\partial\Omega_0\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_0=0 \right\} $       | $ w_l \left(\mathbf{x}\right) = 0 $  |
# | $\partial\Omega_1\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_0=d_{x_0} \right\} $ | $ w_l \left(\mathbf{x}\right) = 0 $  |
# | $\partial\Omega_2\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_1=0 \right\} $       | $ w_l \left(\mathbf{x}\right) = 10 $ |
# | $\partial\Omega_3\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_1=d_{x_1} \right\} $ | $ w_l \left(\mathbf{x}\right) = 0 $  |
# | $\partial\Omega_4\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_2=0 \right\} $       | $ w_l \left(\mathbf{x}\right) = 0 $  |
# | $\partial\Omega_5\doteq\left\{\mathbf{x}\in\overline{\Omega}:x_2=d_{x_2} \right\} $ | $ w_l \left(\mathbf{x}\right) = 0 $  |
#
# ### The Code
#
# All the ingredients are ready to put together the simulation.
#
# #### Importing the Needed Packages
#
# We start by importing what we need:
------------------

[0;36m  Input [0;32mIn [1][0;36m[0m
[0;31m    copy if you make any changes!**[0m
[0m    ^[0m
[0;31mSyntaxError[0m[0;31m:[0m expected 'else' after 'if' expression

SyntaxError: expected 'else' after 'if' expression (990051305.py, line 9)

